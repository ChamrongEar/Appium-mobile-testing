/**
 * @returns {Promise<string[]>}
 */
export function getConnectedDevices(): Promise<string[]>;
export class RealDevice {
    /**
     * @param {string} udid
     * @param {import('@appium/types').AppiumLogger} [logger]
     */
    constructor(udid: string, logger?: import("@appium/types").AppiumLogger | undefined);
    udid: string;
    _log: import("@appium/types").AppiumLogger;
    devicectl: Devicectl;
    /**
     * @returns {import('@appium/types').AppiumLogger}
     */
    get log(): import("@appium/types").AppiumLogger;
    /**
     * @param {string} bundleId
     */
    remove(bundleId: string): Promise<void>;
    /**
     * @param {string} bundleId
     */
    removeApp(bundleId: string): Promise<void>;
    /**
     *
     * @param {string} app
     * @param {number} [timeout]
     * @param {'ios-deploy'|'serial'|'parallel'|null} strategy
     * @privateRemarks This really needs type guards built out
     */
    install(app: string, timeout?: number | undefined, strategy?: 'ios-deploy' | 'serial' | 'parallel' | null): Promise<void>;
    /**
     * @param {string} bundlePathOnPhone
     * @param {boolean} [isUpgrade=false]
     */
    installOrUpgradeApplication(bundlePathOnPhone: string, isUpgrade?: boolean | undefined): Promise<void>;
    /**
     * Alias for {@linkcode install}
     * @param {string} app
     * @param {number} timeout
     * @param {'ios-deploy'|'serial'|'parallel'|null} strategy
     */
    installApp(app: string, timeout: number, strategy: 'ios-deploy' | 'serial' | 'parallel' | null): Promise<void>;
    /**
     * Return an application object if test app has 'bundleid'.
     * The target bundleid can be User and System apps.
     *
     * @param {string} bundleId The bundleId to ensure it is installed
     * @return {Promise<boolean>} Returns True if the app is installed
     * on the device under test.
     */
    isAppInstalled(bundleId: string): Promise<boolean>;
    /**
     * Fetches various attributes, like bundle id, version, entitlements etc. of
     * an installed application.
     *
     * @param {string} bundleId the bundle identifier of an app to check
     * @param {string|string[]|undefined} returnAttributes If provided then
     * only fetches the requested attributes of the app into the resulting object.
     * Some apps may have too many attributes, so it makes sense to limit these
     * by default if you don't need all of them.
     * @returns {Promise<Object|undefined>} Either app info as an object or undefined
     * if the app is not found.
     */
    fetchAppInfo(bundleId: string, returnAttributes?: string | string[] | undefined): Promise<any | undefined>;
    /**
     * @param {string} bundleId
     * @param {string} platformVersion
     * @returns {Promise<boolean>}
     */
    terminateApp(bundleId: string, platformVersion: string): Promise<boolean>;
    /**
     * @param {string} bundleName The name of CFBundleName in Info.plist
     *
     * @returns {Promise<string[]>} A list of User level apps' bundle ids which has
     *                          'CFBundleName' attribute as 'bundleName'.
     */
    getUserInstalledBundleIdsByBundleName(bundleName: string): Promise<string[]>;
    /**
     * @returns {Promise<string>}
     */
    getPlatformVersion(): Promise<string>;
    /**
     * @param {import('./driver').XCUITestDriverOpts} opts
     * @returns {Promise<void>}
     */
    reset({ bundleId, fullReset, platformVersion }: import('./driver').XCUITestDriverOpts): Promise<void>;
}
export default RealDevice;
import { Devicectl } from './devicectl';
//# sourceMappingURL=real-device.d.ts.map